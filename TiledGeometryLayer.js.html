<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: layers/geometry/TiledGeometryLayer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: layers/geometry/TiledGeometryLayer.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>require("./geometry.js");
require("../SingleLayer.js");
require("./CanvasRenderer.js");
require("../stylers/MapCssStyler.js");
require("../../../lib/canvasLayer/leaflet_canvas_layer.js");

// RBush inserts itself as NodeJs module so we must retrieve it this way.
var rbush = require("../../../lib/rbush.js");



/**
 * Base class for layers using client side rendering of tiles containing geographical features in the SCM map viewer component.
 *
 * The tiles contents will be retrieved using a data provided supporting tiling as needed to cover the viewing area.
 *
 * @class
 * @abstract
 */
SMC.layers.geometry.TiledGeometryLayer = L.TileLayer.Canvas.extend(
    /** @lends SMC.layers.geometry.TiledGeometryLayer# */
    {


        includes: SMC.Util.deepClassInclude([SMC.layers.SingleLayer, SMC.layers.geometry.CanvasRenderer]),

        tree: null,
        tileSize: 256,

        initialize: function(options) {
            L.Util.setOptions(this, options);
            this.on("featuresUpdated", function(event) {
                this.updateFeature(event.feature);

            });

            this.drawTile = function(canvas, tilePoint, zoom) {
                var ctx = {
                    canvas: canvas,
                    tile: tilePoint,
                    zoom: this._getZoomForUrl()
                };

                if (this.tree === null || this.lastZoom != zoom) {
                    this.tree = rbush(9, ['.minx', '.miny', '.maxx', '.maxy']);
                    this.lastZoom = zoom;
                }


                this._draw(ctx);
            };
        },



        onAdd: function(map) {
            L.TileLayer.Canvas.prototype.onAdd.call(this, map);
            SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
            map.on("dragstart", function() {
                this.dragging = true;
            }, this);
            map.on("dragend", function() {
                this.dragging = false;
            }, this);

        },

        _draw: function(ctx) {


            var bounds = this._tileBounds(ctx);


            var request = this.createRequest(bounds, ctx);
            var loader = $.ajax;
            var self = this;
            loader($.extend(request, {
                success: function(response) {
                    console.log(response.features);
                    self.addTiledGeometryFromFeatures(response.features, ctx);

                }
            }, this.options.request));
        },

        addTiledGeometryFromFeatures: function(features, ctx, skipTree) {
            var f;
            if (L.Util.isArray(features)) {
                f = features;
            } else if (arguments.length > 1) {
                f = arguments;
            } else {
                f = [features];
            }



            for (i = 0; i &lt; f.length; i++) {
                var feature = f[i];

                //We store the retrieved features in a search tree.
                if (!skipTree) {
                    var treeNode = this._createTreeData(feature, ctx.tile);
                    this.tree.insert(treeNode);
                }
            }


            if (f.length !== 0) {

                this.renderCanvas(ctx, f, this._map);
            }


        },

        _createTreeData: function(feature, tilePoint) {

            var bbox = this._featureBBox(feature);


            return {
                id: feature.properties.id,
                feature: feature,
                minx: bbox.min.x,
                maxx: bbox.max.x,
                miny: bbox.min.y,
                maxy: bbox.max.y,
                tilePoint: tilePoint
            };

        },

        _featureBBox: function(feature) {
            var points = [];
            // if(feature.properties.id ==35)
            //    debugger;
            var geom = feature.geometry.coordinates;
            var type = feature.geometry.type;
            switch (type) {
                case 'Point':
                case 'LineString':
                case 'Polygon':
                    points = [geom];
                    break;

                case 'MultiPoint':
                case 'MultiLineString':

                    for (var j = 0; j &lt; geom.length; j++) {
                        points = points.concat(geom[j]);
                    }

                    break;
                case 'MultiPolygon':
                    if (L.Util.isArray(geom[0])) {
                        geom = geom[0];

                    }

                    for (var j = 0; j &lt; geom.length; j++) {
                        points = points.concat(geom[j]);
                    }

                    break;

                default:
                    throw new Error('Unmanaged type: ' + type);
            }


            return L.bounds(points);
        },



        _tileBounds: function(ctx) {
            var nwPoint = ctx.tile.multiplyBy(this.tileSize);
            var sePoint = nwPoint.add(new L.Point(this.tileSize, this.tileSize));

            // optionally, enlarge request area.
            // with this I can draw points with coords outside this tile area,
            // but with part of the graphics actually inside this tile.
            // NOTE: that you should use this option only if you're actually drawing points!
            var buf = this.options.buffer;
            if (buf > 0) {
                var diff = new L.Point(buf, buf);
                nwPoint = nwPoint.subtract(diff);
                sePoint = sePoint.add(diff);
            }

            var nwCoord = this._map.unproject(nwPoint, ctx.zoom, true);
            var seCoord = this._map.unproject(sePoint, ctx.zoom, true);
            return [nwCoord.lng, seCoord.lat, seCoord.lng, nwCoord.lat];
        },

        updateFeature: function(feature) {

            var bbox = this._featureBBox(feature);

            var intersectingFeatureNodes = this.tree.search([bbox.min.x, bbox.min.y, bbox.max.x, bbox.max.y]);

            // var bounds = [[bbox.min.y, bbox.min.x], [bbox.max.y,bbox.max.x]];
            // var border = new L.rectangle(bounds, {color: 'gray'}).addTo(this._map);

            // we determine the tiles to be redrawn from the features.
            var readdedTileKeys = [];
            for (var i = 0; i &lt; intersectingFeatureNodes.length; i++) {
                var featureTilePoint = intersectingFeatureNodes[i].tilePoint;

                // intersectingFeatureNodes[i].feature._item.selected = true;
                var key = featureTilePoint.x + ":" + featureTilePoint.y;

                if (readdedTileKeys.indexOf(key) &lt; 0) {

                    readdedTileKeys.push(key);
                    var tile = this._tiles[key];
                    if (this._map) { // If we removed the layer we don't want updates.


                        var ctx = {
                            canvas: tile,
                            tile: featureTilePoint,
                            zoom: this._getZoomForUrl() // fix for https://github.com/CloudMade/Leaflet/pull/993
                        };


                        var tileFeatures = this.tree.search(this._tileBounds(ctx));

                        var updatedFeatures = [];
                        for (var j = 0; j &lt; tileFeatures.length; j++) {
                            var existingFeature = tileFeatures[j].feature;

                            if (existingFeature.properties.cartodb_id == feature.properties.cartodb_id) {
                                // We update the data!!!!
                                for (var field in feature) {
                                    if (feature.hasOwnProperty(field)) {
                                        existingFeature[field] = feature[field];
                                    }

                                }

                                existingFeature._dirty = true;
                                existingFeature._item.selected = true;
                                this._features.push(existingFeature);

                            }



                            updatedFeatures.push(existingFeature);
                        }



                        if (!this.dragging) {
                            // To prevent redraws while dragging.
                            this.addTiledGeometryFromFeatures(updatedFeatures, ctx, true);
                        } else {
                            this._map.addOneTimeEventListener("dragend", function() {
                                this.addTiledGeometryFromFeatures(updatedFeatures, ctx, true);
                            }, this)
                        }

                    }
                }
            }

        },

        createRequest: function(bounds, ctx) {
            // override with your code
        }

    });
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="SMC.controls.layerTree.LayerTreeControl.html">LayerTreeControl</a></li><li><a href="SMC.controls.layerTree.LayerTreeFolder.html">LayerTreeFolder</a></li><li><a href="SMC.controls.layerTree.LayerTreeLeaf.html">LayerTreeLeaf</a></li><li><a href="SMC.controls.layerTree.LayerTreeNode.html">LayerTreeNode</a></li><li><a href="SMC.layers.aggregation.AggregatingLayer.html">AggregatingLayer</a></li><li><a href="SMC.layers.Folder.html">Folder</a></li><li><a href="SMC.layers.geometry.GeometryLayer.html">GeometryLayer</a></li><li><a href="SMC.layers.geometry.TiledGeometryLayer.html">TiledGeometryLayer</a></li><li><a href="SMC.layers.Layer.html">Layer</a></li><li><a href="SMC.layers.markers.AtmosphereRTMarkerLayer.html">AtmosphereRTMarkerLayer</a></li><li><a href="SMC.layers.markers.MarkerLayer.html">MarkerLayer</a></li><li><a href="SMC.layers.markers.WFSMarkerLayer.html">WFSMarkerLayer</a></li><li><a href="SMC.layers.reloaders.LayerReloader.html">LayerReloader</a></li><li><a href="SMC.layers.reloaders.ReloadTrigger.html">ReloadTrigger</a></li><li><a href="SMC.layers.reloaders.TimerReloadTrigger.html">TimerReloadTrigger</a></li><li><a href="SMC.layers.SingleLayer.html">SingleLayer</a></li><li><a href="SMC.layers.stylers.MapCssStyler.html">MapCssStyler</a></li><li><a href="SMC.layers.stylers.MarkerCssStyler.html">MarkerCssStyler</a></li><li><a href="SMC.layers.stylers.Styler.html">Styler</a></li><li><a href="SMC.layers.TileLayer.html">TileLayer</a></li><li><a href="SMC.layers.WMSLayer.html">WMSLayer</a></li><li><a href="SMC.Map.html">Map</a></li><li><a href="SMC.providers.AtmosphereRTFeatureProvider.html">AtmosphereRTFeatureProvider</a></li><li><a href="SMC.providers.FeatureHistory.html">FeatureHistory</a></li><li><a href="SMC.providers.FeatureHistoryProvider.html">FeatureHistoryProvider</a></li><li><a href="SMC.providers.FeaturesProvider.html">FeaturesProvider</a></li><li><a href="SMC.providers.RTFeatureProvider.html">RTFeatureProvider</a></li><li><a href="SMC.providers.URLFeatureProvider.html">URLFeatureProvider</a></li><li><a href="SMC.providers.WFSProvider.html">WFSProvider</a></li></ul><h3>Events</h3><ul><li><a href="SMC.layers.reloaders.ReloadTrigger.html#event:reloadTriggered">reloadTriggered</a></li><li><a href="SMC.layers.reloaders.TimerReloadTrigger.html#event:reloadTriggered">reloadTriggered</a></li><li><a href="SMC.providers.FeatureHistoryProvider.html#event:featureHistoryLoaded">featureHistoryLoaded</a></li><li><a href="SMC.providers.FeaturesProvider.html#event:featuresLoaded">featuresLoaded</a></li></ul><h3>Namespaces</h3><ul><li><a href="SMC.html">SMC</a></li><li><a href="SMC.controls.html">controls</a></li><li><a href="SMC.controls.layerTree.html">layerTree</a></li><li><a href="SMC.layers.html">layers</a></li><li><a href="SMC.layers.aggregation.html">aggregation</a></li><li><a href="SMC.layers.geometry.html">geometry</a></li><li><a href="SMC.layers.markers.html">markers</a></li><li><a href="SMC.layers.reloaders.html">reloaders</a></li><li><a href="SMC.layers.stylers.html">stylers</a></li><li><a href="SMC.providers.html">providers</a></li></ul><h3>Mixins</h3><ul><li><a href="SMC.LayerLoader.html">LayerLoader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createNodeHTML">createNodeHTML</a></li><li><a href="global.html#doFeaturesLoading">doFeaturesLoading</a></li><li><a href="global.html#getParamsFromOptions">getParamsFromOptions</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#onAdd">onAdd</a></li><li><a href="global.html#onRemove">onRemove</a></li><li><a href="global.html#setVisible">setVisible</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha8</a> on Mon Jun 23 2014 17:44:51 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
